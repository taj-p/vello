// Copyright 2025 the Vello Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

#![allow(
    clippy::cast_possible_truncation,
    reason = "All resulting values are tested for correctness"
)]

//! Build script to generate gamma correction lookup tables.
//!
//! Generates 8 anchor LUTs (2KB total). At runtime, we interpolate between
//! the two nearest anchors for any given luminance.
//!
//! We intentionally don't upload a LUT for every possible luminance value
//! to avoid bloating the binary size.

use peniko::color::{ColorSpace, Srgb};
use std::env;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

/// 8 uniformly-spaced anchor luminances: i * 255 / 7 for i in 0..8
const ANCHOR_LUMINANCES: [u8; 8] = [0, 36, 72, 109, 145, 182, 218, 255];

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("gamma_luts.rs");
    let mut f = BufWriter::new(File::create(dest_path).unwrap());

    writeln!(f, "// Auto-generated by build.rs - do not edit manually").unwrap();
    writeln!(f).unwrap();
    writeln!(
        f,
        "/// The 8 anchor luminance values for which we have precomputed LUTs."
    )
    .unwrap();
    writeln!(
        f,
        "pub(crate) const ANCHOR_LUMINANCES: [u8; 8] = {:?};",
        ANCHOR_LUMINANCES
    )
    .unwrap();
    writeln!(f).unwrap();

    // Write the 8 anchor LUTs
    writeln!(
        f,
        "/// Gamma correction lookup tables at 8 anchor luminances."
    )
    .unwrap();
    writeln!(f, "///").unwrap();
    writeln!(
        f,
        "/// For luminances between anchors, interpolate between the two nearest LUTs."
    )
    .unwrap();
    writeln!(
        f,
        "/// This achieves â‰¤2 units of error compared to the full 256-luminance LUT."
    )
    .unwrap();
    writeln!(f, "pub(crate) const GAMMA_LUTS: [[u8; 256]; 8] = [").unwrap();

    for (i, &luminance) in ANCHOR_LUMINANCES.iter().enumerate() {
        write!(f, "    // luminance = {}\n    [", luminance).unwrap();
        for alpha in 0_u8..=255 {
            let corrected = compute_corrected_alpha(luminance, alpha);
            if alpha == 255 {
                write!(f, "{corrected}").unwrap();
            } else if alpha % 16 == 15 {
                write!(f, "{corrected},\n     ").unwrap();
            } else {
                write!(f, "{corrected}, ").unwrap();
            }
        }
        if i == 7 {
            writeln!(f, "]").unwrap();
        } else {
            writeln!(f, "],").unwrap();
        }
    }

    writeln!(f, "];").unwrap();

    println!("cargo::rerun-if-changed=build.rs");
}

fn compute_corrected_alpha(luminance_u8: u8, alpha_u8: u8) -> u8 {
    let src = luminance_u8 as f64 / 255.0;
    let dst = 1.0 - src;
    let alpha = alpha_u8 as f64 / 255.0;

    if alpha_u8 == 0 {
        return 0;
    }
    if alpha_u8 == 255 {
        return 255;
    }

    let diff = src - dst;
    if diff.abs() < 0.004 {
        return alpha_u8;
    }

    let lin_src = srgb_to_linear(src);
    let lin_dst = srgb_to_linear(dst);
    let lin_blend = lin_src * alpha + lin_dst * (1.0 - alpha);
    let srgb_blend = linear_to_srgb(lin_blend);
    let corrected = (srgb_blend - dst) / diff;

    (corrected.clamp(0.0, 1.0) * 255.0 + 0.5) as u8
}

#[inline(always)]
fn srgb_to_linear(x: f64) -> f64 {
    Srgb::to_linear_srgb([x as f32, 0.0, 0.0])[0] as f64
}

#[inline(always)]
fn linear_to_srgb(x: f64) -> f64 {
    Srgb::from_linear_srgb([x as f32, 0.0, 0.0])[0] as f64
}
